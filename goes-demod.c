
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <math.h>

#include <liquid.h>

#include <correct.h>

/*
Convert complex BPSK samples from the radio to viterbi decoded bits and estimate signal quality
*/

// possible change - split the analog and digital into separate threads communicating over a pipe

// Viterbi and differential encoded sync word 0x1ACFFC1D
// mask out the first 10 bits because those are influenced by the contents of the previous data
uint8_t syncmask[8]  = {0x00,0x3f,0xff,0xff,0xff,0xff,0xff,0xff};
uint8_t syncpatt[8] = {0x00,0xb1,0x0b,0x02,0xf3,0x3d,0x20,0x76};

// 255 byte scrambler sequence to XOR with data
unsigned char pn[] = {
    0xff, 0x48, 0x0e, 0xc0, 0x9a, 0x0d, 0x70, 0xbc,
    0x8e, 0x2c, 0x93, 0xad, 0xa7, 0xb7, 0x46, 0xce,
    0x5a, 0x97, 0x7d, 0xcc, 0x32, 0xa2, 0xbf, 0x3e,
    0x0a, 0x10, 0xf1, 0x88, 0x94, 0xcd, 0xea, 0xb1,
    0xfe, 0x90, 0x1d, 0x81, 0x34, 0x1a, 0xe1, 0x79,
    0x1c, 0x59, 0x27, 0x5b, 0x4f, 0x6e, 0x8d, 0x9c,
    0xb5, 0x2e, 0xfb, 0x98, 0x65, 0x45, 0x7e, 0x7c,
    0x14, 0x21, 0xe3, 0x11, 0x29, 0x9b, 0xd5, 0x63,
    0xfd, 0x20, 0x3b, 0x02, 0x68, 0x35, 0xc2, 0xf2,
    0x38, 0xb2, 0x4e, 0xb6, 0x9e, 0xdd, 0x1b, 0x39,
    0x6a, 0x5d, 0xf7, 0x30, 0xca, 0x8a, 0xfc, 0xf8,
    0x28, 0x43, 0xc6, 0x22, 0x53, 0x37, 0xaa, 0xc7,
    0xfa, 0x40, 0x76, 0x04, 0xd0, 0x6b, 0x85, 0xe4,
    0x71, 0x64, 0x9d, 0x6d, 0x3d, 0xba, 0x36, 0x72,
    0xd4, 0xbb, 0xee, 0x61, 0x95, 0x15, 0xf9, 0xf0,
    0x50, 0x87, 0x8c, 0x44, 0xa6, 0x6f, 0x55, 0x8f,
    0xf4, 0x80, 0xec, 0x09, 0xa0, 0xd7, 0x0b, 0xc8,
    0xe2, 0xc9, 0x3a, 0xda, 0x7b, 0x74, 0x6c, 0xe5,
    0xa9, 0x77, 0xdc, 0xc3, 0x2a, 0x2b, 0xf3, 0xe0,
    0xa1, 0x0f, 0x18, 0x89, 0x4c, 0xde, 0xab, 0x1f,
    0xe9, 0x01, 0xd8, 0x13, 0x41, 0xae, 0x17, 0x91,
    0xc5, 0x92, 0x75, 0xb4, 0xf6, 0xe8, 0xd9, 0xcb,
    0x52, 0xef, 0xb9, 0x86, 0x54, 0x57, 0xe7, 0xc1,
    0x42, 0x1e, 0x31, 0x12, 0x99, 0xbd, 0x56, 0x3f,
    0xd2, 0x03, 0xb0, 0x26, 0x83, 0x5c, 0x2f, 0x23,
    0x8b, 0x24, 0xeb, 0x69, 0xed, 0xd1, 0xb3, 0x96,
    0xa5, 0xdf, 0x73, 0x0c, 0xa8, 0xaf, 0xcf, 0x82,
    0x84, 0x3c, 0x62, 0x25, 0x33, 0x7a, 0xac, 0x7f,
    0xa4, 0x07, 0x60, 0x4d, 0x06, 0xb8, 0x5e, 0x47,
    0x16, 0x49, 0xd6, 0xd3, 0xdb, 0xa3, 0x67, 0x2d,
    0x4b, 0xbe, 0xe6, 0x19, 0x51, 0x5f, 0x9f, 0x05,
    0x08, 0x78, 0xc4, 0x4a, 0x66, 0xf5, 0x58};

// CCSDS TM Synchronization and Channel Coding Annex F Table F-1
// Convert to and from the dual basis (l) and conventional basis (a)
uint8_t l_of_a[256] = { 0x00, 0x7b, 0xaf, 0xd4, 0x99, 0xe2, 0x36, 0x4d, 0xfa, 0x81, 0x55, 0x2e, 0x63, 0x18, 0xcc, 0xb7, 0x86, 0xfd, 0x29, 0x52, 0x1f,
        0x64, 0xb0, 0xcb, 0x7c, 0x07, 0xd3, 0xa8, 0xe5, 0x9e, 0x4a, 0x31, 0xec, 0x97, 0x43, 0x38, 0x75, 0x0e, 0xda, 0xa1, 0x16, 0x6d, 0xb9, 0xc2, 0x8f, 0xf4,
        0x20, 0x5b, 0x6a, 0x11, 0xc5, 0xbe, 0xf3, 0x88, 0x5c, 0x27, 0x90, 0xeb, 0x3f, 0x44, 0x09, 0x72, 0xa6, 0xdd, 0xef, 0x94, 0x40, 0x3b, 0x76, 0x0d, 0xd9,
        0xa2, 0x15, 0x6e, 0xba, 0xc1, 0x8c, 0xf7, 0x23, 0x58, 0x69, 0x12, 0xc6, 0xbd, 0xf0, 0x8b, 0x5f, 0x24, 0x93, 0xe8, 0x3c, 0x47, 0x0a, 0x71, 0xa5, 0xde,
        0x03, 0x78, 0xac, 0xd7, 0x9a, 0xe1, 0x35, 0x4e, 0xf9, 0x82, 0x56, 0x2d, 0x60, 0x1b, 0xcf, 0xb4, 0x85, 0xfe, 0x2a, 0x51, 0x1c, 0x67, 0xb3, 0xc8, 0x7f,
        0x04, 0xd0, 0xab, 0xe6, 0x9d, 0x49, 0x32, 0x8d, 0xf6, 0x22, 0x59, 0x14, 0x6f, 0xbb, 0xc0, 0x77, 0x0c, 0xd8, 0xa3, 0xee, 0x95, 0x41, 0x3a, 0x0b, 0x70,
        0xa4, 0xdf, 0x92, 0xe9, 0x3d, 0x46, 0xf1, 0x8a, 0x5e, 0x25, 0x68, 0x13, 0xc7, 0xbc, 0x61, 0x1a, 0xce, 0xb5, 0xf8, 0x83, 0x57, 0x2c, 0x9b, 0xe0, 0x34,
        0x4f, 0x02, 0x79, 0xad, 0xd6, 0xe7, 0x9c, 0x48, 0x33, 0x7e, 0x05, 0xd1, 0xaa, 0x1d, 0x66, 0xb2, 0xc9, 0x84, 0xff, 0x2b, 0x50, 0x62, 0x19, 0xcd, 0xb6,
        0xfb, 0x80, 0x54, 0x2f, 0x98, 0xe3, 0x37, 0x4c, 0x01, 0x7a, 0xae, 0xd5, 0xe4, 0x9f, 0x4b, 0x30, 0x7d, 0x06, 0xd2, 0xa9, 0x1e, 0x65, 0xb1, 0xca, 0x87,
        0xfc, 0x28, 0x53, 0x8e, 0xf5, 0x21, 0x5a, 0x17, 0x6c, 0xb8, 0xc3, 0x74, 0x0f, 0xdb, 0xa0, 0xed, 0x96, 0x42, 0x39, 0x08, 0x73, 0xa7, 0xdc, 0x91, 0xea,
        0x3e, 0x45, 0xf2, 0x89, 0x5d, 0x26, 0x6b, 0x10, 0xc4, 0xbf };

uint8_t a_of_l[256] = { 0x00, 0xcc, 0xac, 0x60, 0x79, 0xb5, 0xd5, 0x19, 0xf0, 0x3c, 0x5c, 0x90, 0x89, 0x45, 0x25, 0xe9, 0xfd, 0x31, 0x51, 0x9d,
        0x84, 0x48, 0x28, 0xe4, 0x0d, 0xc1, 0xa1, 0x6d, 0x74, 0xb8, 0xd8, 0x14, 0x2e, 0xe2, 0x82, 0x4e, 0x57, 0x9b, 0xfb, 0x37, 0xde, 0x12, 0x72, 0xbe, 0xa7,
        0x6b, 0x0b, 0xc7, 0xd3, 0x1f, 0x7f, 0xb3, 0xaa, 0x66, 0x06, 0xca, 0x23, 0xef, 0x8f, 0x43, 0x5a, 0x96, 0xf6, 0x3a, 0x42, 0x8e, 0xee, 0x22, 0x3b, 0xf7,
        0x97, 0x5b, 0xb2, 0x7e, 0x1e, 0xd2, 0xcb, 0x07, 0x67, 0xab, 0xbf, 0x73, 0x13, 0xdf, 0xc6, 0x0a, 0x6a, 0xa6, 0x4f, 0x83, 0xe3, 0x2f, 0x36, 0xfa, 0x9a,
        0x56, 0x6c, 0xa0, 0xc0, 0x0c, 0x15, 0xd9, 0xb9, 0x75, 0x9c, 0x50, 0x30, 0xfc, 0xe5, 0x29, 0x49, 0x85, 0x91, 0x5d, 0x3d, 0xf1, 0xe8, 0x24, 0x44, 0x88,
        0x61, 0xad, 0xcd, 0x01, 0x18, 0xd4, 0xb4, 0x78, 0xc5, 0x09, 0x69, 0xa5, 0xbc, 0x70, 0x10, 0xdc, 0x35, 0xf9, 0x99, 0x55, 0x4c, 0x80, 0xe0, 0x2c, 0x38,
        0xf4, 0x94, 0x58, 0x41, 0x8d, 0xed, 0x21, 0xc8, 0x04, 0x64, 0xa8, 0xb1, 0x7d, 0x1d, 0xd1, 0xeb, 0x27, 0x47, 0x8b, 0x92, 0x5e, 0x3e, 0xf2, 0x1b, 0xd7,
        0xb7, 0x7b, 0x62, 0xae, 0xce, 0x02, 0x16, 0xda, 0xba, 0x76, 0x6f, 0xa3, 0xc3, 0x0f, 0xe6, 0x2a, 0x4a, 0x86, 0x9f, 0x53, 0x33, 0xff, 0x87, 0x4b, 0x2b,
        0xe7, 0xfe, 0x32, 0x52, 0x9e, 0x77, 0xbb, 0xdb, 0x17, 0x0e, 0xc2, 0xa2, 0x6e, 0x7a, 0xb6, 0xd6, 0x1a, 0x03, 0xcf, 0xaf, 0x63, 0x8a, 0x46, 0x26, 0xea,
        0xf3, 0x3f, 0x5f, 0x93, 0xa9, 0x65, 0x05, 0xc9, 0xd0, 0x1c, 0x7c, 0xb0, 0x59, 0x95, 0xf5, 0x39, 0x20, 0xec, 0x8c, 0x40, 0x54, 0x98, 0xf8, 0x34, 0x2d,
        0xe1, 0x81, 0x4d, 0xa4, 0x68, 0x08, 0xc4, 0xdd, 0x11, 0x71, 0xbd };

void reed_solomon_decode(correct_reed_solomon *rs,uint8_t *buf,int *errs)
{
	uint8_t coded[255];
	uint8_t decoded[223];
	uint8_t writebuf[892];

	for(int i=0;i<1020;i++) {
		buf[i] ^= pn[i%255];
	}

	for(int i=0;i<4;i++) {
		for(int j=0;j<255;j++) {
			coded[j] = a_of_l[buf[j*4+i]];
		}
		ssize_t retval = correct_reed_solomon_decode(rs,coded,255,decoded);
		if(retval == -1) {
			errs[i] = -1;
		} else {
			int nerr=0;
			for(int j=0;j<223;j++) {
				if(decoded[j] != coded[j]) nerr += 1;
				writebuf[j*4+i] = l_of_a[decoded[j]];
			}
			errs[i] = nerr;
		}
	}
	for(int i=0;i<4;i++) {
		for(int j=0;j<223;j++) {
			buf[i*223+j] = writebuf[i*223+j];
		}
	}
}

// Change sync word detection

int main(int argc, char **argv)
{

	// DSN uses 0x6D 0x4F, CCSDS uses 0x4F 0x6D
	// liquid-dsp's fec uses the DSN so we use libcorrect here.
	uint16_t vpoly[2] = {0x4F,0x6D};
	correct_convolutional *correct_viterbi = correct_convolutional_create(2,7,vpoly);

	correct_reed_solomon *correct_rs = correct_reed_solomon_create(correct_rs_primitive_polynomial_ccsds, 112, 11, 32);

	float input_sample_rate = 2.5e6;
	float symbol_rate = 927e3;
	modulation_scheme ms = LIQUID_MODEM_BPSK;
	float alpha = 0.3f;
	FILE *fin = NULL;
	FILE *fout = NULL;
	//FILE *bitlog = fopen("bitlog.txt","w");
	int c;
	while((c=getopt(argc,argv,"a:hqbr:s:i:o:")) != -1) {
		switch(c) {
			case 'h':
				puts("-h show help");
				puts("-a alpha -- set root raised cosine filter");
				puts("-b -- demodulate BPSK");
				puts("-r rate -- set input sample rate (default 256e3)");
				puts("-s symrate -- set symbol rate (default 72e3)");
				puts("-i infile -- set input file, - for stdin");
				puts("-o outfile -- set output file, - for stdout");
				exit(0);
				break;

			case 'a':
				alpha = atof(optarg);
				break;
			case 'b':
				ms = LIQUID_MODEM_BPSK;
				break;
			case 'r':
				input_sample_rate = atof(optarg);
				break;
			case 's':
				symbol_rate = atof(optarg);
				break;
			case 'i':
				if(optarg[0] == '-' && optarg[1] == '\0') {
					fin = stdin;
				} else {
					fin = fopen(optarg,"rb");
				}
				break;
			case 'o':
				if(optarg[0] == '-' && optarg[1] == '\0') {
					fout = stdout;
				} else {
					fout = fopen(optarg,"wb");
				}
				break;

			case '?':
			default:
				exit(1);
				break;
		}
	}

	if(fin == NULL || fout == NULL) {
		fprintf(stderr, "Error, must specify input and output file with -i and -o\n");
		exit(1);
	}

	unsigned int k = 2;	// target samples per symbol

	float r = k * symbol_rate / input_sample_rate;
	printf("Resampling rate: %f\n",r);

	float slsl=60.0f;
	msresamp_crcf msresampler = msresamp_crcf_create(r,slsl);

	unsigned int buf_len = 16384;
	float complex buf_msresamp[buf_len];
	float complex buf_out[buf_len];

	float complex buf_agc[buf_len];
	agc_crcf agc = agc_crcf_create();
	agc_crcf_set_bandwidth(agc,0.01);

	int ftype = LIQUID_FIRFILT_RRC;
	unsigned int m = 15;
	modemcf demod = modemcf_create(ms);	

	float complex buf_sync[buf_len];
	unsigned int npfb = 32;
	symsync_crcf sync = symsync_crcf_create_rnyquist(ftype,k,m,alpha,npfb);
	symsync_crcf_set_lf_bw(sync,0.001);

	float complex buf_pll[buf_len];
	nco_crcf nco = nco_crcf_create(LIQUID_VCO);
	nco_crcf_pll_set_bandwidth(nco,0.001);

	int ibit = 0;

	uint32_t nagc,nread,nout,nsync,npll;

	//FILE *freqlog = fopen("freqlog.txt","w");
	//FILE *synclog = fopen("synclog.txt","w");

	uint32_t nw;

	const int nsb = 64;
	uint8_t syncmaskbits[nsb];
	uint8_t syncpattbits[nsb];

	liquid_unpack_bytes(syncmask,nsb/8,syncmaskbits,nsb,&nw);
	liquid_unpack_bytes(syncpatt,nsb/8,syncpattbits,nsb,&nw);

	int blocknum = 0;
	float viterbi_score=0;
	
	float varI,varQ,SNR=0.;

	int isyncsearch=0;
	uint8_t syncsearch[64];

	int isoftbuf=0;
	// The soft buffer contains a 64 b sync word, the data, and then another 64b sync word
	// We use the sync words as the extra wrapping for the viterbi decoding.
	int SBLEN = 16384 + 64;
	uint8_t softbuf[SBLEN];
	//int last = 0;
	int errs[4]={-1,-1,-1,-1};

	printf("count\tsiglvl\tS\tN\tSNR\tpllrate\tconverr\tRS\n");
	void update_term() {
		printf("\r%d\t%.1f\t%.3f\t%.3f\t%.3f\t%.3f\t%.4f\t%d %d %d %d             ",blocknum,agc_crcf_get_rssi(agc),varI-varQ,varQ,SNR,nco_crcf_get_frequency(nco),viterbi_score,errs[0],errs[1],errs[2],errs[3]);
	}

	int sync_state = 0;

	while(1) {
		nread = fread(buf_msresamp,sizeof(float complex)*buf_len,1,fin);
		if(nread != 1) break;

		// resample rate to 2 samples per symbol
		msresamp_crcf_execute(msresampler,buf_msresamp,buf_len,buf_agc,&nagc);
		agc_crcf_execute_block(agc,buf_agc,nagc,buf_sync);
		nsync = nagc;

		// BPSK symbol synchronization before PLL
		symsync_crcf_execute(sync,buf_sync,nsync,buf_pll,&npll);

		nout = npll;
		for(int i=0;i<nout;i++) {
			// BPSK carrier tracking and demodulation
			nco_crcf_mix_down(nco,buf_pll[i],&buf_out[i]);
			uint8_t softbit;
			uint32_t symbol;
			modemcf_demodulate_soft(demod,buf_out[i],&symbol,&softbit);
			float phase_error = modemcf_get_demodulator_phase_error(demod);
			nco_crcf_pll_step(nco,phase_error);
			nco_crcf_step(nco);

			if(nco_crcf_get_frequency(nco) > 0.4) {
				nco_crcf_set_frequency(nco,0.4);
			}
			else if(nco_crcf_get_frequency(nco) < -0.4) {
				nco_crcf_set_frequency(nco,-0.4);
			}

			/*
			Accumulate data for synchronization word search and Viterbi decode.

			We have 54 certain bits (or their inverse) to match in the synchronization process.
			synchronization correlation is used to decide when to perform a Viterbi and Reed Solomon decode
			A successful Reed Solomon decode means we've sync'd up, and don't need to correlate to find the next block.

			State 0: Looking for a sync marker. Perform full correlation.
			When a correlation of sufficient strength is found, launch Viterbi and Reed Solomon decoders
			If sync is good, go to state 1
			State 1: We have a sync marker. Receive data until we have a block.
			Send block to Viterbi and Reed Solomon decoders
			If we have a good block, continue in state 1
			If we have a bad block, go back to state 0 (drop data)
			*/

			// search for synchronization word. when found, go to sync_state 1;
			if(sync_state == 0) {
				syncsearch[isyncsearch] = softbit;
				isyncsearch = (isyncsearch+1)%nsb;
				int64_t corr=0;
				for(size_t i=10;i<nsb;i++) {	// i=10 to mask uncertain bits in sync pattern
					int64_t sb = syncsearch[(i+isyncsearch)%nsb];
					corr += (sb-127) * (2*(int64_t)syncpattbits[i]-1);
				}
				corr /= 127;

				if(abs(corr) > 20) {
					sync_state = 1;
					for(isoftbuf=0;isoftbuf<nsb;isoftbuf++) {
						softbuf[isoftbuf] = syncsearch[(isoftbuf+isyncsearch)%nsb];
					}
				}
			} else if(sync_state == 1) {
				// synchronization marker has been found, attempt decode.
				softbuf[isoftbuf] = softbit;
				isoftbuf += 1;
				if(isoftbuf == SBLEN) {

					uint8_t postviterbi[1024 + 4];
					uint8_t postviterbibits[8192+32];
					uint8_t dediff[8192+32];
					uint8_t reencbytes[2048+8];
					uint8_t hardbits[SBLEN];
					uint8_t out[1024+4];
					correct_convolutional_decode_soft(correct_viterbi,softbuf,SBLEN,postviterbi);

					liquid_unpack_bytes(postviterbi,1024+4,postviterbibits,8192+32,&nw);

					for(int j=1;j<8192+32;j++) {
						dediff[j] = postviterbibits[j] ^ postviterbibits[j-1];
					}
					liquid_pack_bytes(dediff,8192+32,out,1024+4,&nw);

					/*
					printf("\n");
					for(int j=0;j<16;j++) {
						printf("%02x ",out[j]);
					}
					printf("%d\n",ibit-last);
					last = ibit;
					*/
					
					correct_convolutional_encode(correct_viterbi,postviterbi,1028,reencbytes);
					liquid_unpack_bytes(reencbytes,2048+8,hardbits,16384+64,&nw);

					viterbi_score = 0.0;
					for(int j=64;j<SBLEN-64;j++) {
						viterbi_score += (softbuf[j] > 127) != hardbits[j];
					}
					viterbi_score /= SBLEN-128;

					reed_solomon_decode(correct_rs,&out[4],errs);

					if(errs[0] == -1 && errs[1] == -1 && errs[2] == -1 && errs[3] == -1) {
						sync_state = 0;
						isoftbuf = 0;
					} else {
						fwrite(&out[4],892,1,fout);
						memcpy(softbuf,&softbuf[SBLEN-64],64);
						isoftbuf = 64;
					}

					blocknum++;

					update_term();
				}
			}

			ibit += 1;
		}
		// Estimate signal to noise metrics
		for(int i=0;i<nout;i++) {
			float x = crealf(buf_out[i]);
			float y = cimagf(buf_out[i]);
			varI += x*x;
			varQ += y*y;
		}
		varI /= nout;
		varQ /= nout;

		float varS = varI - varQ;
		SNR = varS / varQ;
		//fwrite(buf_out,sizeof(float complex)*nout,1,fout);

		//fprintf(freqlog,"%f\n",nco_crcf_get_frequency(nco));
		//fprintf(synclog,"%f\n",symsync_crcf_get_rate(sync));
		//update_term();
	}
	printf("\n");

	msresamp_crcf_destroy(msresampler);
	agc_crcf_destroy(agc);
	symsync_crcf_destroy(sync);
	correct_convolutional_destroy(correct_viterbi);
	correct_reed_solomon_destroy(correct_rs);
	nco_crcf_destroy(nco);
	modemcf_destroy(demod);

	return 0;
}


